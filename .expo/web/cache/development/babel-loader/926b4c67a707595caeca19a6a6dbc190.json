{"ast":null,"code":"import { memo } from 'react';\nimport { usePropsResolution } from '../../../hooks/useThemeProps';\nimport { useBreakpointValue, useTheme, useToken } from '../../../hooks';\nimport { useColorMode } from '../../../core/color-mode/hooks';\nimport Platform from \"react-native-web/dist/exports/Platform\";\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s1, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s1 = _i.next()).done); _n = true) {\n      _arr.push(_s1.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nvar _s = $RefreshSig$();\n\nexport function Hidden(_param) {\n  var children = _param.children,\n      props = _objectWithoutProperties(_param, [\"children\"]);\n\n  _s();\n\n  var ref = usePropsResolution('Hidden', props, {}, {\n    ignoreProps: ['only', 'platform']\n  }),\n      from = ref.from,\n      till = ref.till,\n      only = ref.only,\n      platform = ref.platform,\n      colorMode = ref.colorMode;\n  var breakpoints = useTheme().breakpoints;\n  var currentColorMode = useColorMode();\n  var breakpointValueObject = Object.keys(breakpoints).reduce(function (obj, val) {\n    obj[val] = val;\n    return obj;\n  }, {});\n  var breakpointValue = useBreakpointValue(breakpointValueObject);\n\n  var ref1 = _slicedToArray(useToken('breakpoints', [breakpointValue]), 1),\n      currentBreakpointValue = ref1[0];\n\n  var ref2 = _slicedToArray(useToken('breakpoints', [from]), 1),\n      fromBreakPointValue = ref2[0];\n\n  var ref3 = _slicedToArray(useToken('breakpoints', [till]), 1),\n      tillBreakPointValue = ref3[0];\n\n  if (!from && !till && !only && !colorMode && !platform) {\n    return null;\n  } else if (from && till && currentBreakpointValue >= fromBreakPointValue && currentBreakpointValue < tillBreakPointValue) {\n    return null;\n  } else if (from && !till && currentBreakpointValue >= fromBreakPointValue) {\n    return null;\n  } else if (till && !from && currentBreakpointValue < tillBreakPointValue) {\n    return null;\n  } else if (Array.isArray(only) && only.includes(breakpointValue) || only === breakpointValue) {\n    return null;\n  } else if (Array.isArray(platform) && platform.includes(Platform.OS) || platform === Platform.OS) {\n    return null;\n  } else if (colorMode === currentColorMode.colorMode) {\n    return null;\n  }\n\n  return children;\n}\n\n_s(Hidden, \"SsRVChUSwdETJkgsIKtKl7o5Vc8=\", false, function () {\n  return [usePropsResolution, useTheme, useColorMode, useBreakpointValue, useToken, useToken, useToken];\n});\n\n_c = Hidden;\nexport default _c1 = memo(Hidden);\n\nvar _c, _c1;\n\n$RefreshReg$(_c, \"Hidden\");\n$RefreshReg$(_c1, \"%default%\");\n;\n;\n\n(function () {\n  var _a, _b;\n\n  if (typeof self !== 'undefined' && '$RefreshHelpers$' in self) {\n    var currentExports = __webpack_module__.exports;\n    var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      __webpack_module__.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      });\n\n      import.meta.webpackHot.accept();\n\n      if (prevExports !== null) {\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          __webpack_module__.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        __webpack_module__.hot.invalidate();\n      }\n    }\n  }\n})();","map":{"version":3,"sources":["C:\\projects\\json-color-palette-generator\\node_modules\\native-base\\lib\\module\\components\\primitives\\Hidden\\index.js"],"names":["memo","usePropsResolution","useBreakpointValue","useTheme","useToken","useColorMode","Hidden","children","props","from","till","only","platform","colorMode","ignoreProps","breakpoints","currentColorMode","breakpointValueObject","Object","keys","reduce","obj","val","breakpointValue","currentBreakpointValue","fromBreakPointValue","tillBreakPointValue","Array","isArray","includes","Platform","OS"],"mappings":"AAAA,SAASA,IAAT,QAAqB,OAArB;AACA,SAASC,kBAAT,QAAmC,8BAAnC;AACA,SAASC,kBAAT,EAA6BC,QAA7B,EAAuCC,QAAvC,QAAuD,gBAAvD;AACA,SAASC,YAAT,QAA6B,gCAA7B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,OAAM,SAAUC,MAAV,CAAiB,MAAjB,EAGH;MAFDC,QAAQ,GADa,MAGtB,CAFCA,Q;MACGC,KAAK,GAAA,wBAAA,CAFa,MAEb,EACT,CAFCD,UAED,CADS,C;;;;AAER,MAMIN,GAEF,GAFEA,kBAAkB,CAAC,QAAD,EAAWO,KAAX,EAAkB,EAAlB,EAAsB;AAC1CM,IAAAA,WAAW,EAAE,CAAC,MAAD,EAAS,UAAT;AAD6B,GAAtB,CANtB;AAAA,MACEL,IAAI,GAKFR,GAEF,CAPAQ,IADF;AAAA,MAEEC,IAAI,GAIFT,GAEF,CANAS,IAFF;AAAA,MAGEC,IAAI,GAGFV,GAEF,CALAU,IAHF;AAAA,MAIEC,QAAQ,GAENX,GAEF,CAJAW,QAJF;AAAA,MAKEC,SAAS,GACPZ,GAEF,CAHAY,SALF;AASA,MACEE,WAAW,GACTZ,QAAQ,GADVY,WADF;AAGA,MAAMC,gBAAgB,GAAGX,YAAY,EAArC;AACA,MAAMY,qBAAqB,GAAGC,MAAM,CAACC,IAAPD,CAAYH,WAAZG,EAAyBE,MAAzBF,CAAgC,UAACG,GAAD,EAAMC,GAAN,EAAc;AAC1ED,IAAAA,GAAG,CAACC,GAAD,CAAHD,GAAWC,GAAXD;AACA,WAAOA,GAAP;AACD,GAH6BH,EAG3B,EAH2BA,CAA9B;AAIA,MAAMK,eAAe,GAAGrB,kBAAkB,CAACe,qBAAD,CAA1C;;AACA,MAAiCb,IAA0C,GAAA,cAAA,CAA1CA,QAAQ,CAAC,aAAD,EAAgB,CAACmB,eAAD,CAAhB,CAAkC,EAAD,CAAC,CAA3E;AAAA,MAAOC,sBAAsB,GAAIpB,IAA0C,CAAA,CAAA,CAA3E;;AACA,MAA8BA,IAA+B,GAAA,cAAA,CAA/BA,QAAQ,CAAC,aAAD,EAAgB,CAACK,IAAD,CAAhB,CAAuB,EAAD,CAAC,CAA7D;AAAA,MAAOgB,mBAAmB,GAAIrB,IAA+B,CAAA,CAAA,CAA7D;;AACA,MAA8BA,IAA+B,GAAA,cAAA,CAA/BA,QAAQ,CAAC,aAAD,EAAgB,CAACM,IAAD,CAAhB,CAAuB,EAAD,CAAC,CAA7D;AAAA,MAAOgB,mBAAmB,GAAItB,IAA+B,CAAA,CAAA,CAA7D;;AAEA,MAAE,CAAGK,IAAH,IAAO,CAAKC,IAAZ,IAAgB,CAAKC,IAArB,IAAyB,CAAKE,SAA9B,IAAuC,CAAKD,QAA9C,EAAwD;AACtD,WAAO,IAAP;AACD,GAFD,MAGK,IAAIH,IAAI,IAAIC,IAARD,IAAgBe,sBAAsB,IAAIC,mBAA1ChB,IAAiEe,sBAAsB,GAAGE,mBAA9F,EAAmH;AACpH,WAAO,IAAP;AACD,GAFE,MAGE,IAAIjB,IAAI,IAAA,CAAKC,IAATD,IAAiBe,sBAAsB,IAAIC,mBAA/C,EAAoE;AACrE,WAAO,IAAP;AACD,GAFE,MAGE,IAAIf,IAAI,IAAA,CAAKD,IAATC,IAAiBc,sBAAsB,GAAGE,mBAA9C,EAAmE;AACpE,WAAO,IAAP;AACD,GAFE,MAIE,IAAIC,KAAK,CAACC,OAAND,CAAchB,IAAdgB,KAAuBhB,IAAI,CAACkB,QAALlB,CAAcY,eAAdZ,CAAvBgB,IAAyDhB,IAAI,KAAKY,eAAtE,EAAuF;AACxF,WAAO,IAAP;AACD,GAFE,MAIE,IAAII,KAAK,CAACC,OAAND,CAAcf,QAAde,KAA2Bf,QAAQ,CAACiB,QAATjB,CAAkBkB,QAAQ,CAACC,EAA3BnB,CAA3Be,IAA6Df,QAAQ,KAAKkB,QAAQ,CAACC,EAAvF,EAA2F;AAC5F,WAAO,IAAP;AACD,GAFE,MAGE,IAAIlB,SAAS,KAAKG,gBAAgB,CAACH,SAAnC,EAA8C;AAC/C,WAAO,IAAP;AACD;;AAEb,SAAON,QAAP;AACD;;GAnDeD,M,EAAM,8B,EAAA,K,EAAA,YAAA;UAUhBL,kB,EAKAE,Q,EACqBE,Y,EAKDH,kB,EACSE,Q,EACHA,Q,EACAA,Q;;;KAxBhBE,M;AAoDhB,eAA4BN,GAAAA,GAAAA,IAAI,CAACM,MAAD,CAAhC","sourcesContent":["import { memo } from 'react';\nimport { usePropsResolution } from '../../../hooks/useThemeProps';\nimport { useBreakpointValue, useTheme, useToken } from '../../../hooks';\nimport { useColorMode } from '../../../core/color-mode/hooks';\nimport { Platform } from 'react-native';\nexport function Hidden({\n  children,\n  ...props\n}) {\n  const {\n    from,\n    till,\n    only,\n    platform,\n    colorMode\n  } = usePropsResolution('Hidden', props, {}, {\n    ignoreProps: ['only', 'platform']\n  });\n  const {\n    breakpoints\n  } = useTheme();\n  const currentColorMode = useColorMode();\n  const breakpointValueObject = Object.keys(breakpoints).reduce((obj, val) => {\n    obj[val] = val;\n    return obj;\n  }, {});\n  const breakpointValue = useBreakpointValue(breakpointValueObject);\n  const [currentBreakpointValue] = useToken('breakpoints', [breakpointValue]);\n  const [fromBreakPointValue] = useToken('breakpoints', [from]);\n  const [tillBreakPointValue] = useToken('breakpoints', [till]); //if no prop is passed, it will hide the element wrapped with hidden\n\n  if (!from && !till && !only && !colorMode && !platform) {\n    return null;\n  } //if from and till prop exists, it will hide the element wrapped accordingly\n  else if (from && till && currentBreakpointValue >= fromBreakPointValue && currentBreakpointValue < tillBreakPointValue) {\n      return null;\n    } //if from prop exists, it will hide the element wrapped starting from that breakpoint.\n    else if (from && !till && currentBreakpointValue >= fromBreakPointValue) {\n        return null;\n      } //if till prop exists, it will hide the element wrapped starting from  0 till that breakpoint.\n      else if (till && !from && currentBreakpointValue < tillBreakPointValue) {\n          return null;\n        } //if only prop exists and is array, check that array consists current breakpoint value, and if that exists, hide on that breakpoint to next breakpoint.\n        // if only prop is string, hide on that breakpoint to next breakpoint.\n        else if (Array.isArray(only) && only.includes(breakpointValue) || only === breakpointValue) {\n            return null;\n          } //if platform prop exists and is array, check that array consists current platform value, and if that exists, hide on that platform.\n          // if platform prop is string, hide on that platform.\n          else if (Array.isArray(platform) && platform.includes(Platform.OS) || platform === Platform.OS) {\n              return null;\n            } //if colormode prop is valid string, hide on that colormode.\n            else if (colorMode === currentColorMode.colorMode) {\n                return null;\n              }\n\n  return children;\n}\nexport default /*#__PURE__*/memo(Hidden);\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}