{"ast":null,"code":"import get from 'lodash.get';\nimport isNil from 'lodash.isnil';\nimport mergeWith from 'lodash.mergewith';\nimport cloneDeep from 'lodash.clonedeep';\nimport { themePropertyMap } from './../../theme/base';\nimport { getClosestBreakpoint, findLastValidBreakpoint, hasValidBreakpointFormat, extractInObject } from './../../theme/tools';\nimport { useContrastText } from '../useContrastText';\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === \"function\") {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _throw(e) {\n  throw e;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nexport function extractProps(props, theme, param, componentTheme, currentBreakpoint) {\n  var param = param !== null ? param : _throw(new TypeError(\"Cannot destructure undefined\"));\n  var newProps = {};\n\n  for (var property in props) {\n    if (themePropertyMap[property]) {\n      var propValues = extractPropertyFromFunction(property, props, theme, componentTheme);\n\n      if (typeof propValues === 'string' || typeof propValues === 'number') {\n        newProps[property] = propValues;\n      } else if (!isNil(propValues)) {\n        for (var nestedProp in propValues) {\n          newProps[nestedProp] = get(theme, \"\".concat(themePropertyMap[nestedProp], \".\").concat(propValues[nestedProp]), propValues[nestedProp]);\n        }\n      } else if (property === 'shadow') {\n        var shadowProps = theme[themePropertyMap[property]][props[property]];\n\n        if (!isNil(shadowProps)) {\n          newProps = _objectSpread({}, newProps, shadowProps);\n        }\n      } else {\n        newProps[property] = resolveValueWithBreakpoint(props[property], theme.breakpoints, currentBreakpoint, property);\n      }\n    } else {\n      newProps[property] = resolveValueWithBreakpoint(props[property], theme.breakpoints, currentBreakpoint, property);\n    }\n  }\n\n  return cloneDeep(newProps);\n}\n\nfunction filterDefaultProps(props, defaultProps) {\n  var ref = _slicedToArray(extractInObject(defaultProps, Object.keys(props)), 2),\n      resultProps = ref[1];\n\n  return resultProps;\n}\n\nexport var extractPropertyFromFunction = function extractPropertyFromFunction(property, props, theme, componentTheme) {\n  var propValues;\n\n  if (componentTheme && typeof componentTheme[themePropertyMap[property]] === 'function') {\n    var funcProps = componentTheme[themePropertyMap[property]](_objectSpread({\n      theme: theme\n    }, props));\n    var isNested = Object.keys(funcProps).some(function (key) {\n      return funcProps[key] && typeof funcProps[key] === 'object';\n    });\n    propValues = isNested ? _objectSpread({}, get(funcProps, \"\".concat(props[property]))) : _objectSpread({}, funcProps);\n  } else {\n    propValues = get(componentTheme, \"\".concat(themePropertyMap[property], \".\").concat(props[property]));\n  }\n\n  return propValues;\n};\nexport function mergeUnderscoreProps(newProps, props) {\n  var _s = $RefreshSig$();\n\n  var _props = Object.keys(newProps).filter(function (propName) {\n    return propName.startsWith('_');\n  });\n\n  _props.forEach(_s(function (propName) {\n    _s();\n\n    var _newProps$bg, _newProps$propName$co, _newProps$propName, _props$propName;\n\n    var bg = (_newProps$bg = newProps.bg) !== null && _newProps$bg !== void 0 ? _newProps$bg : newProps.backgroundColor;\n    var textColor = bg ? {\n      color: useContrastText(bg, (_newProps$propName$co = (_newProps$propName = newProps[propName]) === null || _newProps$propName === void 0 ? void 0 : _newProps$propName.color) !== null && _newProps$propName$co !== void 0 ? _newProps$propName$co : (_props$propName = props[propName]) === null || _props$propName === void 0 ? void 0 : _props$propName.color)\n    } : {};\n    newProps[propName] = _objectSpread({}, textColor, newProps[propName], props[propName]);\n  }, \"au9PS1pGMSvlwCC87VHk+2CfJX8=\", false, function () {\n    return [useContrastText];\n  }));\n\n  return newProps;\n}\nexport var resolveValueWithBreakpoint = function resolveValueWithBreakpoint(values, breakpointTheme, currentBreakpoint, property) {\n  if (hasValidBreakpointFormat(values, breakpointTheme, property)) {\n    return findLastValidBreakpoint(values, breakpointTheme, currentBreakpoint);\n  } else {\n    return values;\n  }\n};\nexport function calculateProps(theme, colorModeProps, componentTheme, props, windowWidth) {\n  var currentBreakpoint = getClosestBreakpoint(theme.breakpoints, windowWidth);\n\n  if (!props) {\n    props = {};\n  }\n\n  var newProps;\n\n  if (componentTheme) {\n    newProps = extractProps(filterDefaultProps(props, componentTheme.defaultProps), theme, colorModeProps, componentTheme, currentBreakpoint);\n    var componentBaseStyle = typeof componentTheme.baseStyle !== 'function' ? componentTheme.baseStyle : componentTheme.baseStyle(_objectSpread({\n      theme: theme\n    }, newProps, props, colorModeProps));\n    newProps = mergeWith(newProps, componentBaseStyle, function (objValue, srcValue, key) {\n      if (!isNil(objValue)) {\n        delete newProps[key];\n      }\n    });\n    var variant = props.variant || get(componentTheme, 'defaultProps.variant');\n\n    if (variant && componentTheme.variants && componentTheme.variants[variant]) {\n      var colorScheme = props.colorScheme || get(componentTheme, 'defaultProps.colorScheme');\n      var variantProps = componentTheme.variants[variant](_objectSpread({}, props, newProps, {\n        colorScheme: colorScheme,\n        theme: theme\n      }, colorModeProps));\n      variantProps = extractProps(variantProps, theme, colorModeProps, componentTheme, currentBreakpoint);\n      newProps = mergeWith(newProps, variantProps, function (objValue, srcValue, key) {\n        if (!isNil(objValue)) {\n          delete newProps[key];\n        }\n      });\n      delete newProps.variant;\n      delete newProps.colorScheme;\n    }\n  }\n\n  var extractedProps = extractProps(props, theme, colorModeProps, componentTheme, currentBreakpoint);\n  newProps = mergeWith(newProps, extractedProps, function (objValue, srcValue, key) {\n    if (!isNil(objValue)) {\n      delete newProps[key];\n    }\n  });\n  newProps = mergeUnderscoreProps(newProps, props);\n  return newProps;\n}\n;\n;\n\n(function () {\n  var _a, _b;\n\n  if (typeof self !== 'undefined' && '$RefreshHelpers$' in self) {\n    var currentExports = __webpack_module__.exports;\n    var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      __webpack_module__.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      });\n\n      import.meta.webpackHot.accept();\n\n      if (prevExports !== null) {\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          __webpack_module__.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        __webpack_module__.hot.invalidate();\n      }\n    }\n  }\n})();","map":{"version":3,"sources":["C:\\projects\\json-color-palette-generator\\node_modules\\native-base\\lib\\module\\hooks\\useThemeProps\\utils.js"],"names":["get","isNil","mergeWith","cloneDeep","themePropertyMap","getClosestBreakpoint","findLastValidBreakpoint","hasValidBreakpointFormat","extractInObject","useContrastText","extractProps","props","theme","componentTheme","currentBreakpoint","newProps","property","propValues","extractPropertyFromFunction","nestedProp","concat","shadowProps","resolveValueWithBreakpoint","breakpoints","filterDefaultProps","defaultProps","resultProps","Object","keys","funcProps","isNested","some","key","mergeUnderscoreProps","_props","filter","propName","startsWith","forEach","_newProps$bg","_newProps$propName$co","_newProps$propName","_props$propName","bg","backgroundColor","textColor","color","values","breakpointTheme","calculateProps","colorModeProps","windowWidth","componentBaseStyle","baseStyle","objValue","srcValue","variant","variants","colorScheme","variantProps","extractedProps"],"mappings":"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","sourcesContent":["import get from 'lodash.get';\nimport isNil from 'lodash.isnil';\nimport mergeWith from 'lodash.mergewith';\nimport cloneDeep from 'lodash.clonedeep';\nimport { themePropertyMap } from './../../theme/base';\nimport { getClosestBreakpoint, findLastValidBreakpoint, hasValidBreakpointFormat, extractInObject } from './../../theme/tools';\nimport { useContrastText } from '../useContrastText';\n/*\n Extract props from theme props and omit those from props\n*/\n\n/**\n *\n * @param props Props passed by the user\n * @param theme Theme object\n * @param colorModeProps `colorMode` object\n * @param componentTheme Theme for specific components\n * @param currentBreakpoint Current breakpoint values\n * @returns Extracting props from defaultProps while overriding the props that are already present\n */\n\nexport function extractProps(props, theme, {}, componentTheme, currentBreakpoint) {\n  let newProps = {};\n\n  for (let property in props) {\n    // If the property exists in themePropertyMap then get its value\n    if (themePropertyMap[property]) {\n      let propValues = extractPropertyFromFunction(property, props, theme, componentTheme);\n\n      if (typeof propValues === 'string' || typeof propValues === 'number') {\n        newProps[property] = propValues;\n      } else if (!isNil(propValues)) {\n        for (let nestedProp in propValues) {\n          newProps[nestedProp] = get(theme, \"\".concat(themePropertyMap[nestedProp], \".\").concat(propValues[nestedProp]), propValues[nestedProp]);\n        }\n      } else if (property === 'shadow') {\n        let shadowProps = theme[themePropertyMap[property]][props[property]];\n\n        if (!isNil(shadowProps)) {\n          newProps = { ...newProps,\n            ...shadowProps\n          };\n        }\n      } else {\n        newProps[property] = resolveValueWithBreakpoint(props[property], theme.breakpoints, currentBreakpoint, property);\n      }\n    } else {\n      newProps[property] = resolveValueWithBreakpoint(props[property], theme.breakpoints, currentBreakpoint, property);\n    }\n  }\n\n  return cloneDeep(newProps);\n}\n/*\nRemove props from defaultProps that are already present in props\n*/\n\nfunction filterDefaultProps(props, defaultProps) {\n  let [, resultProps] = extractInObject(defaultProps, Object.keys(props));\n  return resultProps;\n}\n/**\n * If property is functional in componentTheme, get its returned object\n *\n * @param property : name of the prop\n * @param props : all props\n * @param theme : provided theme without components\n * @param componentTheme : component specific theme\n * @returns\n */\n\n\nexport const extractPropertyFromFunction = (property, props, theme, componentTheme) => {\n  let propValues; // Check if the entry in the theme is a function then calling it with all theme and props as params\n\n  if (componentTheme && typeof componentTheme[themePropertyMap[property]] === 'function') {\n    let funcProps = componentTheme[themePropertyMap[property]]({\n      theme,\n      ...props\n    }); // Check if returned object from componentTheme is a nested object\n\n    let isNested = Object.keys(funcProps).some(function (key) {\n      return funcProps[key] && typeof funcProps[key] === 'object';\n    }); // If the returned value is nested object then find the property value in it, otherwise return the whole object\n\n    propValues = isNested ? { ...get(funcProps, \"\".concat(props[property]))\n    } : { ...funcProps\n    };\n  } else {\n    // If the entry is any value other than function then return the whole object or value\n    propValues = get(componentTheme, \"\".concat(themePropertyMap[property], \".\").concat(props[property]));\n  }\n\n  return propValues;\n};\n/*\nMerge _props and apply contrastText color if not passed by theme or user\n*/\n\nexport function mergeUnderscoreProps(newProps, props) {\n  const _props = Object.keys(newProps).filter(propName => propName.startsWith('_'));\n\n  _props.forEach(propName => {\n    var _newProps$bg, _newProps$propName$co, _newProps$propName, _props$propName;\n\n    // Adding color based on bg contrast if no color is given\n    const bg = (_newProps$bg = newProps.bg) !== null && _newProps$bg !== void 0 ? _newProps$bg : newProps.backgroundColor;\n    const textColor = bg ? {\n      color: useContrastText(bg, (_newProps$propName$co = (_newProps$propName = newProps[propName]) === null || _newProps$propName === void 0 ? void 0 : _newProps$propName.color) !== null && _newProps$propName$co !== void 0 ? _newProps$propName$co : (_props$propName = props[propName]) === null || _props$propName === void 0 ? void 0 : _props$propName.color)\n    } : {}; // Overriding calculated props with user added props\n\n    newProps[propName] = { ...textColor,\n      ...newProps[propName],\n      ...props[propName]\n    };\n  });\n\n  return newProps;\n}\n/**\n *\n * Checks the property and resolves it if it has breakpoints\n * @param values : value from props\n * @param currentBreakpoint : current value for which breakpoint will be calculated\n * @param property : property name\n * @returns\n */\n\nexport const resolveValueWithBreakpoint = (values, breakpointTheme, currentBreakpoint, property) => {\n  if (hasValidBreakpointFormat(values, breakpointTheme, property)) {\n    // Check the last valid breakpoint value from all values\n    // If current breakpoint is `md` and we have `base` then `lg`, then last value will be taken(`base` in this case)\n    return findLastValidBreakpoint(values, breakpointTheme, currentBreakpoint);\n  } else {\n    return values;\n  }\n};\n/**\n * Takes all prop related data and returns the props that needs to be applied to the component\n *\n * @param theme Theme object\n * @param colorModeProps Color mode information\n * @param componentTheme Theme object for the specific component\n * @param props Props passed by the user\n * @param windowWidth Width of the current window\n * @returns props to be applied\n */\n\nexport function calculateProps(theme, colorModeProps, componentTheme, props, windowWidth) {\n  let currentBreakpoint = getClosestBreakpoint(theme.breakpoints, windowWidth);\n\n  if (!props) {\n    props = {};\n  }\n\n  let newProps;\n\n  if (componentTheme) {\n    // Extracting props from defaultProps\n    newProps = extractProps(filterDefaultProps(props, componentTheme.defaultProps), theme, colorModeProps, componentTheme, currentBreakpoint); // Extracting props from base style\n\n    let componentBaseStyle = typeof componentTheme.baseStyle !== 'function' ? componentTheme.baseStyle : componentTheme.baseStyle({\n      theme,\n      ...newProps,\n      ...props,\n      ...colorModeProps\n    });\n    newProps = mergeWith(newProps, componentBaseStyle, // @ts-ignore\n    (objValue, srcValue, key) => {\n      if (!isNil(objValue)) {\n        delete newProps[key];\n      }\n    });\n    const variant = props.variant || get(componentTheme, 'defaultProps.variant'); // Extracting props from variant\n\n    if (variant && componentTheme.variants && componentTheme.variants[variant]) {\n      const colorScheme = props.colorScheme || get(componentTheme, 'defaultProps.colorScheme');\n      let variantProps = componentTheme.variants[variant]({ ...props,\n        ...newProps,\n        colorScheme,\n        theme,\n        ...colorModeProps\n      });\n      variantProps = extractProps(variantProps, theme, colorModeProps, componentTheme, currentBreakpoint); // added this to handle order of props\n\n      newProps = mergeWith(newProps, variantProps, // @ts-ignore\n      (objValue, srcValue, key) => {\n        if (!isNil(objValue)) {\n          delete newProps[key];\n        }\n      });\n      delete newProps.variant;\n      delete newProps.colorScheme;\n    }\n  } // Extracting props from normal props\n\n\n  let extractedProps = extractProps(props, theme, colorModeProps, componentTheme, currentBreakpoint); // added this to handle order of props\n  // @ts-ignore\n\n  newProps = mergeWith(newProps, extractedProps, (objValue, srcValue, key) => {\n    if (!isNil(objValue)) {\n      delete newProps[key];\n    }\n  });\n  newProps = mergeUnderscoreProps(newProps, props);\n  return newProps;\n}\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}